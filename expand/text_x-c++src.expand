#!/usr/bin/python
# -*- coding: utf-8 -*-

from libkatepate import ui

def main():
    return \
'''int main(int argc, const char* const argv[])
{
    %{cursor}
    return 0;
}
'''

def fori(count):
    return 'for (int i = 0; i < ' + count + '; ++i)\n    ${cursor}'

def fore(typename, name):
    template = \
'''for (
    {0}::const_iterator it = {1}.begin()
  , last = {1}.end()
  ; it != last
  ; ++it
  )
{{
    %{{cursor}}
}}
'''
    return template.format(typename, name)

def st(name, *templateParams):
    ''' Insert a structure definition

        A first mandatory parameter is a structure name.
        Everything after that will be template parameters.
        Template parameter declaration may contain a default value:
          st(foo, T, U = T, V = int)

        will expand into:
          template <typename T, typename U = T, typename V = int>
          struct foo
          {
          };
    '''
    if len(templateParams):
        template = \
'''/**
 * \\brief {0}
 */
template <{1}>
struct {0}
{{
}};
'''
        return template.format(name, 'typename ' + ', typename '.join(templateParams))
    template = \
'''/**
 * \\brief {0}
 */
struct {0}
{{
}};
'''
    return template.format(name)

def cl(name, *templateParams):
    ''' Insert a class definition

        TODO It would be neat to have syntax like this:
            cl(test, T, U, d=v, cc=del, mv=def)
          i.e. define a class 'test' w/ template params T and U,
          w/ virtual detor, w/ deleted copy ctor/assign and w/
          defaulted move ctor/assign.

          Isn't it?
    '''
    if len(templateParams):
        template = \
'''/**
 * \\brief {0}
 */
template <{1}>
class {0}
{{
    %{{cursor}}explicit {0}()
    {{
    }}
    virtual ~{0}()
    {{
    }}
}};
'''
        return template.format(name, 'typename ' + ', typename '.join(templateParams))
    template = \
'''/**
 * \\brief {0}
 */
class {0}
{{
    %{{cursor}}explicit {0}()
    {{
    }}
    virtual ~{0}()
    {{
    }}
}};
'''
    return template.format(name)

def t():
    return 'template <typename T>'

def brief():
    return \
'''/**
 * \\brief %{cursor}
 *
 */'''

def ns(name = None):
    ''' Insert named or anonymous namespace
    '''
    if bool(name):
        nsList = name.split('::')
        if len(nsList) > 1:
            nsOpen = ''
            nsReverseNames = ''
            for ns in nsList:
                nsOpen += 'namespace ' + ns + ' { '
                if bool(nsReverseNames):
                    nsReverseNames = ns + ', ' + nsReverseNames
                else:
                    nsReverseNames = ns
            nsReverseNames = '}' * len(nsList) + ' ' * (60 - len(nsList)) + '// namespace ' + nsReverseNames
            return nsOpen + '\n\n' + nsReverseNames + '\n'
        else:
            template = \
'''namespace {0} {{
%{{cursor}}
}}                                                           // namespace {0}
'''
    else:
        name = 'anonymous'
        template = \
'''namespace {{
%{{cursor}}
}}                                                           // {0} namespace
'''
    return template.format(name)

def gs(typeT, name, ref = None):
    ''' Insert getter/setter for mem
    '''
    template = \
'''{0} {1}() const
{{
    return {2};
}}
void {1}({0} value)
{{
    {2} = value;
}}%{{cursor}}
'''
    if ref == None:
        arg = typeT
    else:
        arg = 'const ' + typeT + ref

    if name.startswith('m_'):                               # Usual code style: members start w/ 'm_' prefix
        pure_name = name[2:]
    elif name.endswith('_'):                                # Google code style: members end w/ '_' suffix
        pure_name = name[0:-1]
    else:
        pure_name = name

    return template.format(arg, pure_name, name)
